{
  "prompt": "Write a function to find all permutations of a string.",
  "teacher_text": "Here are two approaches to generate all permutations of a string:\n\n### 1. Recursive Backtracking (Educational Approach)\n\n```python\ndef get_permutations(s):\n    \"\"\"\n    Generate all permutations of a string using recursion.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        list: A list of all permutation strings\n        \n    Time Complexity: O(n! * n) where n is the length of the string\n    Space Complexity: O(n! * n) to store all permutations\n    \"\"\"\n    # Base case: empty string or single character\n    if len(s) <= 1:\n        return [s]\n    \n    permutations = []\n    for i, char in enumerate(s):\n        # Get all permutations of the remaining characters\n        remaining = s[:i] + s[i+1:]\n        for perm in get_permutations(remaining):\n            permutations.append(char + perm)\n    \n    return permutations\n\n# Example usage:\nprint(get_permutations(\"abc\"))\n# Output: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n\nprint(get_permutations(\"aab\"))\n# Output: ['aab', 'aba', 'aab', 'aba', 'baa', 'baa'] (includes duplicates)\n```\n\n### 2. Pythonic Approach (Recommended)\n\n```python\nimport itertools\n\ndef get_permutations_pythonic(s):\n    \"\"\"\n    Generate all permutations using itertools.permutations.\n    This is more efficient and Pythonic for production code.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        list: A list of all permutation strings\n    \"\"\"\n    return [''.join(p) for p in itertools.permutations(s)]\n\n# Example usage:\nprint(get_permutations_pythonic(\"abc\"))\n# Output: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n```\n\n### 3. Handling Duplicates (Unique Permutations Only)\n\nIf you want unique permutations when the input has duplicate characters:\n\n```python\ndef get_unique_permutations(s):\n    \"\"\"\n    Generate unique permutations of a string with duplicate handling.\n    \"\"\"\n    if len(s) <= 1:\n        return [s]\n    \n    permutations = set()\n    for i, char in enumerate(s):\n        remaining = s[:i] + s[i+1:]\n        for perm in get_unique_permutations(remaining):\n            permutations.add(char + perm)\n    \n    return list(permutations)\n\nprint(get_unique_permutations(\"aab\"))\n# Output: ['aab', 'aba', 'baa'] (no duplicates)\n```\n\n### Key Points:\n- **Time Complexity**: O(n! \u00d7 n) where n is the string length",
  "teacher_logits": null,
  "metadata": {
    "temperature": 1.0,
    "top_p": 0.95,
    "max_tokens": 1024
  }
}