{
  "prompt": "Explain the concept of a hash table.",
  "teacher_text": "A **hash table** (or hash map) is a data structure that provides ultra-fast lookup, insertion, and deletion of key-value pairs by using a technique called *hashing* to convert keys into array indices.\n\n## The Core Idea: A Smarter Search\n\nImagine a supermarket where you need to find milk. Instead of searching every aisle sequentially, you calculate: *\"Milk starts with 'M', which is the 13th letter, so it must be in aisle 13.\"* You walk directly there\u2014**O(1) constant time**. That's the power of a hash table.\n\n## How It Works: Three Main Parts\n\n### 1. **The Hash Function**\nA special function that takes a key (string, number, object) and converts it into a fixed-size integer (the \"hash code\").\n\n```\nkey \u2192 [Hash Function] \u2192 hash_code\n```\n\nExample: For key `\"apple\"`, a hash function might process the characters to produce `5381`.\n\n### 2. **The Buckets Array**\nAn underlying array where data is actually stored. Each position is called a **bucket** or **slot**.\n\n### 3. **The Index Calculation**\nThe hash code is mapped to a valid array index using modulo arithmetic:\n\n```\nindex = hash_code % array_size\n```\n\nSo if `hash_code = 5381` and `array_size = 100`, `index = 81`.\n\n## Step-by-Step: Inserting & Looking Up\n\n**Insert `\"apple\" \u2192 5`:**\n1. Hash `\"apple\"` \u2192 `5381`\n2. `index = 5381 % 100 = 81`\n3. Store value `5` at `array[81]`\n\n**Lookup `\"apple\"`:**\n1. Hash `\"apple\"` \u2192 `5381` (same result!)\n2. `index = 5381 % 100 = 81`\n3. Return `array[81]` \u2192 `5`\n\nNo searching needed\u2014you calculate the exact location instantly.\n\n## The Collision Problem\n\nSince arrays are finite and hash functions can produce the same output for different inputs, **collisions** happen. Two keys can map to the same index.\n\n### Collision Resolution Methods:\n\n**1. Chaining (most common)**\nEach bucket contains a *linked list* of entries. If `\"banana\"` also hashes to index 81, you add it to the list at `array[81]`.\n\n```\narray[81]: [\"apple\":5] \u2192 [\"banana\":10] \u2192 null\n```\n\n**2. Open Addressing**\nIf the slot is occupied, probe for the next available slot (linear/quadratic probing) or use a second hash function.\n\n## Critical Concepts\n\n### **Load Factor**\n```\nLoad Factor = (number of entries) / (number of buckets)\n```\n- **Low** (e.g., 0.5): Fewer collisions, faster lookups, more memory waste\n- **High** (e.g., 0.9): More collisions, slower lookups, memory efficient\n\n### **Resizing**\nWhen load factor exceeds a threshold (typically 0.75), the hash table:\n1. Creates a new, larger array (often double the size)\n2. Rehashes all existing keys into new positions\n3. This is expensive but keeps operations fast long-term\n\n## Time Complexity\n\n| Operation | Average | Worst Case (rare) |\n|-----------|---------|-------------------|\n| Insert    | O(1)    | O(n)              |\n| Lookup    | O(1)    | O(n)              |\n| Delete    | O(1)    | O(n)              |\n\n*Worst case occurs when all keys collide into one bucket (degenerates to linked list).*\n\n## Advantages vs Disadvantages",
  "teacher_logits": null,
  "metadata": {
    "temperature": 1.0,
    "top_p": 0.95,
    "max_tokens": 1024
  }
}