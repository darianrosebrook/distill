{
  "prompt": "Explain the concept of recursion in programming.",
  "teacher_text": "# Recursion in Programming\n\nRecursion is a programming technique where a **function calls itself** to solve a problem by breaking it down into smaller, similar subproblems. It's a powerful concept that can lead to elegant solutions for certain types of problems.\n\n## The Two Essential Parts\n\nEvery recursive function must have:\n\n1. **Base Case**: The condition that stops the recursion. This is the simplest version of the problem that can be solved without calling the function again.\n\n2. **Recursive Case**: The part where the function calls itself with a modified argument, moving toward the base case.\n\n## Classic Example: Factorial\n\nThe factorial of a number `n` (written as `n!`) is the product of all positive integers up to `n`:\n- `5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1 = 120`\n- Mathematically: `n! = n \u00d7 (n-1)!` with `1! = 1`\n\n```python\ndef factorial(n):\n    # Base case\n    if n == 1:\n        return 1\n    \n    # Recursive case\n    else:\n        return n * factorial(n - 1)\n\n# How it works for factorial(4):\n# factorial(4) returns 4 * factorial(3)\n#   factorial(3) returns 3 * factorial(2)\n#     factorial(2) returns 2 * factorial(1)\n#       factorial(1) returns 1 (base case)\n#     factorial(2) returns 2 * 1 = 2\n#   factorial(3) returns 3 * 2 = 6\n# factorial(4) returns 4 * 6 = 24\n```\n\n## Visualizing the Call Stack\n\nWhen you call a recursive function, each call creates a new **stack frame** in memory with its own variables:\n\n```\nfactorial(4)\n  \u2192 n = 4, waiting for factorial(3)\n    \u2192 n = 3, waiting for factorial(2)\n      \u2192 n = 2, waiting for factorial(1)\n        \u2192 n = 1, returns 1 (base case)\n      \u2192 returns 2 * 1 = 2\n    \u2192 returns 3 * 2 = 6\n  \u2192 returns 4 * 6 = 24\n```\n\nThe stack \"unwinds\" as each call returns its result to the previous one.\n\n## Real-World Analogy\n\nImagine searching for your car keys in a box of nested boxes:\n- **Open a box**: If you find keys, stop (base case)\n- **Find a smaller box**: Open it and repeat the process (recursive case)\n- You keep opening smaller boxes until you either find the keys or run out of boxes\n\n## Common Pitfalls\n\n1. **Missing Base Case**: Leads to infinite recursion and eventually a **stack overflow** error.\n2. **Unreachable Base Case**: The recursive calls never reach the stopping condition.\n3. **Inefficiency**: Can create many duplicate calculations (though this can be mitigated with memoization).\n\n## When to Use Recursion\n\nRecursion is particularly effective for:\n- **",
  "teacher_logits": null,
  "metadata": {
    "temperature": 1.0,
    "top_p": 0.95,
    "max_tokens": 1024
  }
}