{
  "prompt": "Implement a depth-first search algorithm.",
  "teacher_text": "Here's a comprehensive implementation of Depth-First Search (DFS) in Python, including both recursive and iterative versions with adjacency list representation:\n\n```python\nfrom collections import defaultdict\nfrom typing import List, Set, Dict\n\nclass Graph:\n    def __init__(self):\n        \"\"\"Initialize graph using adjacency list representation\"\"\"\n        self.adj_list: Dict[int, List[int]] = defaultdict(list)\n        self.vertices: Set[int] = set()\n    \n    def add_edge(self, u: int, v: int, directed: bool = False):\n        \"\"\"Add edge between vertices u and v\n        Args:\n            u: source vertex\n            v: destination vertex\n            directed: True if graph is directed, False if undirected\n        \"\"\"\n        self.adj_list[u].append(v)\n        self.vertices.add(u)\n        self.vertices.add(v)\n        \n        if not directed:\n            self.adj_list[v].append(u)\n    \n    def dfs_recursive(self, start: int) -> List[int]:\n        \"\"\"DFS using recursion\n        Time: O(V + E), Space: O(V) for recursion stack\n        \"\"\"\n        visited = set()\n        traversal_order = []\n        \n        def dfs(vertex: int):\n            visited.add(vertex)\n            traversal_order.append(vertex)\n            \n            # Explore neighbors\n            for neighbor in self.adj_list[vertex]:\n                if neighbor not in visited:\n                    dfs(neighbor)\n        \n        dfs(start)\n        return traversal_order\n    \n    def dfs_iterative(self, start: int) -> List[int]:\n        \"\"\"DFS using explicit stack (iterative)\n        Time: O(V + E), Space: O(V) for stack\n        \"\"\"\n        visited = set()\n        traversal_order = []\n        stack = [start]\n        \n        while stack:\n            vertex = stack.pop()\n            \n            if vertex not in visited:\n                visited.add(vertex)\n                traversal_order.append(vertex)\n                \n                # Add neighbors to stack (reverse order to maintain same order as recursive)\n                for neighbor in reversed(self.adj_list[vertex]):\n                    if neighbor not in visited:\n                        stack.append(neighbor)\n        \n        return traversal_order\n    \n    def dfs_all_nodes(self, start: int = None) -> List[int]:\n        \"\"\"DFS traversal covering all nodes (handles disconnected graphs)\n        If start is None, picks any vertex\n        \"\"\"\n        visited = set()\n        traversal_order = []\n        \n        # If graph is empty\n        if not self.vertices:\n            return traversal_order\n        \n        # Determine starting vertices\n        if start is not None:\n            start_vertices = [start]\n        else:\n            start_vertices = list(self.vertices)\n        \n        # Visit each unvisited component\n        for vertex in start_vertices:\n            if vertex not in visited:\n                # Use iterative DFS for each component\n                stack = [vertex]\n                while stack:\n                    curr = stack.pop()\n                    \n                    if curr not in visited:\n                        visited.add(curr)\n                        traversal_order.append(curr)\n                        \n                        for neighbor in reversed(self.adj_list[curr]):\n                            if neighbor not in visited:\n                                stack.append(neighbor)\n        \n        return traversal_order\n\n\n# Example Usage\nif __name__ == \"__main__\":\n    # Create a sample graph\n    graph = Graph()\n    # Graph structure:\n    #   0---1---2\n    #   |   |\n    #   3---4\n    #   |\n    #   5\n    edges = [(0, 1), (0, 3), (1, 2), (1, 4), (3, 4), (3, 5)]\n    for u, v in edges:\n        graph.add_edge(u, v)\n    \n    print(\"Graph adjacency list:\")\n    for vertex",
  "teacher_logits": null,
  "metadata": {
    "temperature": 1.0,
    "top_p": 0.95,
    "max_tokens": 1024
  }
}