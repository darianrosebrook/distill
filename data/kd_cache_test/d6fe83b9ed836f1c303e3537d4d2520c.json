{
  "prompt": "Explain the concept of recursion in programming.",
  "teacher_text": "# Recursion in Programming\n\nRecursion is a programming technique where a function **calls itself** directly or indirectly to solve a problem by breaking it down into smaller, similar subproblems.\n\n## Core Concept\n\nA recursive function solves a problem by:\n1. **Reducing** a complex problem into a simpler version of the same problem\n2. **Calling itself** with that simpler version\n3. **Combining** the results until reaching the simplest case\n\n## Two Essential Components\n\nEvery recursive function must have:\n\n### 1. **Base Case** (Termination Condition)\n- The simplest possible version of the problem\n- A condition where the function **stops** calling itself\n- Prevents infinite recursion\n\n### 2. **Recursive Case**\n- The function calls itself with a **modified argument** that moves toward the base case\n- Each call should progress toward the base case\n\n## Classic Example: Factorial\n\n```python\ndef factorial(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    \n    # Recursive case\n    else:\n        return n * factorial(n - 1)\n\n# Execution: factorial(4)\n# = 4 * factorial(3)\n# = 4 * (3 * factorial(2))\n# = 4 * (3 * (2 * factorial(1)))\n# = 4 * (3 * (2 * 1))\n# = 24\n```\n\n## How It Works: The Call Stack\n\nEach recursive call creates a new **stack frame** in memory:\n- Stores the function's local variables and parameters\n- The stack grows with each call\n- When the base case is reached, calls unwind and return values back up the stack\n\n```\nfactorial(4)\n  \u2192 factorial(3)\n    \u2192 factorial(2)\n      \u2192 factorial(1)  # Base case reached\n      \u2190 returns 1\n    \u2190 returns 2 * 1 = 2\n  \u2190 returns 3 * 2 = 6\n\u2190 returns 4 * 6 = 24\n```\n\n## Another Example: Fibonacci Sequence\n\n```python\ndef fibonacci(n):\n    # Base cases\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Recursive case\n    return fibonacci(n - 1) + fibonacci(n - 2)\n```\n\n## Advantages\n\n\u2705 **Elegant code** for naturally hierarchical problems (trees, graphs)  \n\u2705 **Simpler implementation** for certain algorithms (divide-and-conquer)  \n\u2705 **Closely mirrors mathematical definitions**\n\n## Disadvantages\n\n\u274c **Memory intensive** - Each call consumes stack space  \n\u274c **Performance overhead** - Function calls are expensive  \n\u274c **Risk of stack overflow** - Too many recursive calls crash the program  \n\u274c **Can be harder to debug** and understand for complex cases\n\n## Common Pitfalls\n\n### Infinite Recursion\n```python\n# BAD: Missing or unreachable base case\ndef countdown(n):\n    return countdown(n - 1)  # Never stops!\n```\n\n### No Progress Toward Base Case\n```python\n# BAD: Argument doesn't change\ndef bad_recursion(n):\n    if n == 0: return\n    return bad_recursion(n)  # St",
  "teacher_logits": null,
  "metadata": {
    "temperature": 1.0,
    "top_p": 0.95,
    "max_tokens": 1024,
    "timestamp": "2025-11-11T21:24:39.627694"
  }
}